\chapter{Analysis}
\label{chap:analysis}

The debugging activity collected 6890 snapshots over 119 projects. The temperature activity collected 2296 snapshots over 35 projects. In total, 9186 snapshots were analyzed. From these data, features were extracted that represented the type of code change that occurred in a snapshot. Those features are listed in Table \ref{tab:features-extracted}. After some analysis of these change-type features, a new analytical method was constructed to provide teachers with useful information towards identifying flailing, off-task, or disengaged behavior. The new method, called \emph{solution particle analysis,} did not depend on the type of change, instead relying primarily on timing data. 

The particle analysis method allowed for the development of a visual display tool that allowed immediate insight into the state of a classroom in the recorded data, in such a way that would aid a teacher coordinate their resources. This result is further described in TODO%TODO

\begin{table}
\begin{labeling}{Blocks Moved in Context}

	\item [Blocks Added] Block(s) were added to the workspace. Nearly always a single block.
	\item [Blocks Deleted] Block(s) were removed from the workspace.
	\item [Blocks Moved in Space] Block(s) moved position on the workspace, but did not necessarily change programmatic meaning.
	\item [Blocks Moved in Context] Block(s) changed programmatic position, indicating a new parent block and a different place in the app's control flow.
	\item [Fields Changed] A block's text field changed. Could be a text literal, a variable or procedure name, or a number literal.
	\item [Properties Modified] One or more properties of a block has changed, which could indicate use of the mutator to change a block's semantics (such as changing the number of addends in an addition block). Intended as a catch-all if the other tests missed something, and was rarely found in the data.
	\item [Time Stamp] Time of current snapshot, measured in seconds since the first snapshot was made at the creation of the project. The initializing snapshot has a time stamp value of zero.
	\item [Interval] Time since the last snapshot was made. Useful to know how long, in real time, since the student made a change.

\end{labeling}
\caption[Features extracted from snapshots]{Features extracted from snapshot data.}
\label{tab:features-extracted}
\end{table}

\section{Data Consistency and Error Removal}
Some forms of corruption were found in snapshot blocks files. The first two involved patterned corruption of the block file: empty block file and malformed XML. Rarely, a snapshot had no contents for the blocks file. In the entire collection of debugging activity snapshots ($n = 6890$), only three snapshots had empty blocks. These snapshots were removed, and the overall history of that project was unaffected. 

The malformed XML files contained text beyond the closing XML tag, which crashed the XML parser. Within the debugging activities, only seven snapshots had this malformation, which were corrected by trimming the excess text. It was noteworthy in those cases that the junk excess text was a repetition of the last characters of the file.%, as seen in Listing \ref{list:badxmltrailing}. 

The presence of such corruptions were indicative of a bug in the extraction of the block data from blockly in the browser. It was possible that the snapshot mechanism was able to capture the XML file while it was in an inconsistent state, such as mid-write. This bug may be within the Blockly framework itself, and further investigation is recommended before attempting larger-scale deployment of this method.

% \begin{listing}
% \begin{minted}[breaklines]{xml}
%   <block type="component_set_get" id="3" x="579" y="277">
%     <mutation component_type="TextBox" set_or_get="get" property_name="Text" is_generic="false" instance_name="TextBox1_UserInput"></mutation>
%     <field name="COMPONENT_SELECTOR">TextBox1_UserInput</field>
%     <field name="PROP">Text</field>
%   </block>
%   <yacodeblocks ya-version="159" language-version="20"></yacodeblocks>
% </xml> <mutation component_type="TextBox" set_or_get="set" property_name="Text" is_generic="false" instance_name="TextBox1_UserInput"></mutation>
%     <field name="COMPONENT_SELECTOR">TextBox1_UserInput</field>
%     <field name="PROP">Text</field>
%   </block>
%   <yacodeblocks ya-version="159" language-version="20"></yacodeblocks>
% </xml>
% \end{minted}
% \caption[Extra XML beyond the closing tag]{Extra XML where the last segment of text is repeated beyond the closing tag.}
% \label{list:badxmltrailing}
% \end{listing}

The two above corruptions were easily mitigated. A third mode of corruption, however, resulted in properly formed XML, but potentially erroneous data. This mode was characterized by multiple changes happening in a single snapshot, which should have been extremely rare, as each snapshot was triggered by an atomic action in the editor. There was a small amount of event caching, %as discussed in Section \ref{sec:mod-ai},
 however the resolution was sufficient to capture individual character strokes while typing into text fields, indicating that speed was sufficient to separate any user change. One project was particularly egregious, and showed this corruption in 71 of its 245 commits, rendering nearly a third of its data unreliable. That project was removed, which left only 50 such potential errors in the remainder of the database, many of which were mitigated by text field accumulator, described in Section \ref{sec:text-acc}. The total percentage of potentially erroneous snapshots in the debugging activity dataset was 0.84\%, and only 0.7\% remained potentially unmitigated. These are summarized in Table \ref{tab:data-corruption}.

% % Debug:		empty blocks - 3 (now, many were hand-fixed, notes may indicate more)
% %				junk past tag - 7 (now, many were hand-fixed, notes may indicate more)
% %			6890 snapshots total
% % Temperature:	empty blocks - 1 
% %				junk past tag - 4 
% %			2296 snapshots total
	
\begin{table}
\begin{centering}
	\begin{tabular}{l r l p{5.4cm}}
	Corruption Mode 		& \multicolumn{2}{l}{Instance Count} 		& Mitigation Strategy 			\\ \hline
	Empty block file 						&  3 &(0.04\%) 				& snapshot deleted 						\\
	Junk beyond \mintinline{xml}|</xml>| 	&  7 &(0.1\%) 				& junk trimmed, snapshot kept 			\\
	Multiple changes 						& 50 &(0.7\%) 				& accepted as insignificant 			\\
	Multi-session 							&  3 &(0.04\%) 				& data past 40 minutes ignored
	\end{tabular}
	\caption[Data corruption modes]{Data corruption modes, their prevalence, and mitigation strategy.}
	\label{tab:data-corruption}
\end{centering}
\end{table}

A data consistency bug was found where a project was opened over more than one session. If a project was opened in a second, disjoint session, such as the following day, the block ID numbers change, causing the feature extractors to falsely over-report blocks being deleted and added, when really the same blocks have been re-numbered by App Inventor. The strategy employed was to check every project for a large time interval, far beyond the allotted time for the activities, and delete snapshots beyond the large interval. % TODO make sure you actually do this

% \section{Text Field Change Accumulator}
% \label{sec:text-acc}

